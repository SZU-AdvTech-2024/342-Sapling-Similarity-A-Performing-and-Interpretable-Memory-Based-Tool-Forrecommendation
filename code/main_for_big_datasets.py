import numpy as npimport utilsimport mathfrom scipy import sparseimport timefrom parse import parse_argst1 = time.time()args = parse_args()g = args.gammadata = args.datasettest_data = args.testM1 = 10     # number of steps with which we compute B and rec matricesprint("reading data...")if test_data == "validation":    N_users, N_items, M, train, test, = utils.read_data_validation(data)else:    N_users, N_items, M, train, test = utils.read_data(data)M = M.astype(np.float32)m = sparse.csr_matrix(M)print("user-based...")CO = (m*m.T).toarray().astype(np.float32)   # matrix of the co-occurrences between usersk = np.sum(M, axis = 1)                     # vector with the degree of usersN = N_itemsrec_u = np.memmap("memmap/rec_users_{}.dat".format(data),dtype="float32",mode = "w+",shape = (N_users,N_items))      # matrix with the recommendations provided by a user-based approachM2 = math.ceil(N_users/M1)for i in range(M1):    print(round(i/M1*100,2),"%",end = "\r")    co = CO[i*M2:(i+1)*M2,:]    ki = k[i*M2:(i+1)*M2]    kj = k    B = np.nan_to_num((1-(co*(1-co/kj)+(ki-co.T).T*(1-(ki-co.T).T/(N-kj))).T/(ki*(1-ki/N))).T*np.sign(((co*N/kj).T/ki).T-1))    rec_u[i*M2:(i+1)*M2,:] = np.nan_to_num(np.dot(B,M).T/np.sum(abs(B), axis = 1)).Tprint("item-based...")CO = (m.T*m).toarray().astype(np.float32)   # matrix of the co-occurrences between itemsk = np.sum(M, axis = 0)                     # vector with the degree of itemsN = N_usersrec_i = np.memmap("memmap/rec_items_{}.dat".format(data),dtype="float32",mode = "w+",shape = (N_users,N_items))      # matrix with the recommendations provided by an item-based approachM2 = math.ceil(N_items/M1)for i in range(M1):    print(round(i/M1*100,2),"%",end = "\r")    co = CO[:,i*M2:(i+1)*M2]    ki = k    kj = k[i*M2:(i+1)*M2]    B = np.nan_to_num((1-(co*(1-co/kj)+(ki-co.T).T*(1-(ki-co.T).T/(N-kj))).T/(ki*(1-ki/N))).T*np.sign(((co*N/kj).T/ki).T-1))    rec_i[:,i*M2:(i+1)*M2] = np.nan_to_num(np.dot(M,B)/np.sum(abs(B), axis = 0))M = 0m = 0B = 0k = 0CO = 0print("measuring SSCF recommendations...")rec = (1-g)*rec_u+g*rec_iprint("measuring performance of user-based...")scores_user = utils.scores(train, test, rec_u, N_users, N_items, K = 20)print("measuring performance of item-based...")scores_item = utils.scores(train, test, rec_i, N_users, N_items, K = 20)print("measuring performance of SSCF...")scores = utils.scores(train, test, rec, N_users, N_items, K = 20)print("\nRESULTS\n")print("user-based")print("precision@20:\t{}\nrecall@20:\t{}\nndcg@20:\t{}".format(scores_user[0],scores_user[1],scores_user[2]))print("item-based")print("precision@20:\t{}\nrecall@20:\t{}\nndcg@20:\t{}".format(scores_item[0],scores_item[1],scores_item[2]))print("SSCF")print("precision@20:\t{}\nrecall@20:\t{}\nndcg@20:\t{}".format(scores[0],scores[1],scores[2]))t2 = time.time()print(t2-t1,"seconds")